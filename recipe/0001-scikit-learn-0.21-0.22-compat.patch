diff --git a/pyearth/_knot_search.pyx b/pyearth/_knot_search.pyx
index 6c4ea6b..d7b3fb8 100644
--- a/pyearth/_knot_search.pyx
+++ b/pyearth/_knot_search.pyx
@@ -82,7 +82,7 @@ cdef class MultipleOutcomeDependentData:
         self.weights = weights
         
     @classmethod
-    def alloc(cls, FLOAT_t[:,:] y, w, INDEX_t m, INDEX_t n_outcomes, INDEX_t max_terms, FLOAT_t zero_tol):
+    def alloc(cls, const FLOAT_t[:,:] y, w, INDEX_t m, INDEX_t n_outcomes, INDEX_t max_terms, FLOAT_t zero_tol):
         cdef list weights
         cdef list outcomes
         cdef int i, n_weights
diff --git a/pyearth/earth.py b/pyearth/earth.py
index e027d6a..e8d4e0f 100644
--- a/pyearth/earth.py
+++ b/pyearth/earth.py
@@ -3,6 +3,10 @@ from ._pruning import PruningPasser, FEAT_IMP_CRITERIA
 from ._util import ascii_table, apply_weights_2d, gcv
 from ._types import BOOL
 from sklearn.base import RegressorMixin, BaseEstimator, TransformerMixin
+try:
+    from sklearn.base import MultiOutputMixin
+except ImportError:
+    MultiOutputMixin = None
 from sklearn.utils.validation import (assert_all_finite, check_is_fitted,
                                       check_X_y)
 import numpy as np
@@ -10,7 +14,11 @@ from scipy import sparse
 from ._version import get_versions
 __version__ = get_versions()['version']
 
-class Earth(BaseEstimator, RegressorMixin, TransformerMixin):
+class _Earth(MultiOutputMixin or object):
+    def __init__(self, _version=__version__):
+        self._version = _version
+
+class Earth(_Earth, RegressorMixin, TransformerMixin, BaseEstimator):
 
     """
     Multivariate Adaptive Regression Splines
@@ -399,6 +407,10 @@ class Earth(BaseEstimator, RegressorMixin, TransformerMixin):
             raise TypeError('A sparse matrix was passed, but dense data '
                             'is required. Use X.toarray() to convert to '
                             'dense.')
+
+        if getattr(getattr(X, 'dtype', None), 'kind', None) == 'c':
+            raise ValueError('Complex data not supported\n{}\n'.format(X))
+
         X = np.asarray(X, dtype=np.float64, order='F')
         
         # Figure out missingness
@@ -415,8 +427,8 @@ class Earth(BaseEstimator, RegressorMixin, TransformerMixin):
                 raise ValueError(
                     "Input contains NaN, infinity or a value that's too large."
                     "Did you mean to set allow_missing=True?")
-        if X.ndim == 1:
-            X = X[:, np.newaxis]
+        if X.ndim < 2:
+            raise ValueError('Missing features. Need two-dimensional X, got X.ndim=={}.'.format(X.ndim))
 
         # Ensure correct number of columns
         if hasattr(self, 'basis_') and self.basis_ is not None:
@@ -1271,7 +1283,7 @@ class Earth(BaseEstimator, RegressorMixin, TransformerMixin):
 #         mse0 = np.sum(y_sqr * output_weight) / m
         return 1 - (mse / mse0)
 
-    def score_samples(self, X, y=None, missing=None):
+    def score_samples_(self, X, y=None, missing=None):
         '''
 
         Calculate sample-wise fit scores.
diff --git a/pyearth/test/test_earth.py b/pyearth/test/test_earth.py
index d6dfd8b..a1de87e 100644
--- a/pyearth/test/test_earth.py
+++ b/pyearth/test/test_earth.py
@@ -48,7 +48,8 @@ default_params = {"penalty": 1}
 def test_check_estimator():
     numpy.random.seed(0)
     import sklearn.utils.estimator_checks
-    sklearn.utils.estimator_checks.MULTI_OUTPUT.append('Earth')
+    if hasattr(sklearn.utils.estimator_checks, 'MULTI_OUTPUT'):
+        sklearn.utils.estimator_checks.MULTI_OUTPUT.append('Earth')
     sklearn.utils.estimator_checks.check_estimator(Earth)
 
 
@@ -215,7 +216,7 @@ def test_linvars():
     with open(filename, 'r') as fl:
         prev = fl.read()
 
-    assert_equal(res, prev)
+    assert_almost_equal(float(res), float(prev), places=7)
 
 
 def test_linvars_coefs():
diff --git a/pyearth/test/test_export.py b/pyearth/test/test_export.py
index fc38c50..3d2d25d 100644
--- a/pyearth/test/test_export.py
+++ b/pyearth/test/test_export.py
@@ -85,7 +85,7 @@ def test_export_sympy():
                        'logical_not':numpy.logical_not, "greater": numpy.greater, 'maximum':numpy.maximum,
                        'Missing': lambda x: numpy.isnan(x).astype(float),
                        'NaNProtect': lambda x: numpy.where(numpy.isnan(x), 0, x), 'nan': numpy.nan,
-                       'float': float, 'where': numpy.where
+                       'float': float, 'where': numpy.where, 'numpy': numpy
                        }
 
         for i, expression in enumerate(expressions):
